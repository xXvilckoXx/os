; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\New folder\shared\Demo15\SysCore\AHCI\AHCI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?find_cmdslot@@YAHPAUHBA_PORT@@@Z		; find_cmdslot
; Function compile flags: /Ogtpy
; File d:\new folder\shared\demo15\syscore\ahci\ahci.cpp
_TEXT	SEGMENT
_port$ = 8						; size = 4
?find_cmdslot@@YAHPAUHBA_PORT@@@Z PROC			; find_cmdslot

; 23   : 	// If not set in SACT and CI, the slot is free
; 24   : 	uint32_t slots = (port->sact | port->ci);

	mov	eax, DWORD PTR _port$[esp-4]
	mov	ecx, DWORD PTR [eax+56]
	or	ecx, DWORD PTR [eax+52]

; 25   : 	for (int i=0; i<5; i++)

	xor	eax, eax
	npad	4
$LL4@find_cmdsl:

; 26   : 	{
; 27   : 		if ((slots&1) == 0)

	test	cl, 1
	je	SHORT $LN5@find_cmdsl

; 28   : 			return i;
; 29   : 		slots >>= 1;

	inc	eax
	shr	ecx, 1
	cmp	eax, 5
	jl	SHORT $LL4@find_cmdsl

; 30   : 	}
; 31   : 	return -1;

	or	eax, -1
$LN5@find_cmdsl:

; 32   : }

	ret	0
?find_cmdslot@@YAHPAUHBA_PORT@@@Z ENDP			; find_cmdslot
_TEXT	ENDS
PUBLIC	?read@@YA_NPAUHBA_PORT@@IIIPAG@Z		; read
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_port$ = 8						; size = 4
_startl$ = 12						; size = 4
_starth$ = 16						; size = 4
_count$ = 20						; size = 4
_buf$ = 24						; size = 4
?read@@YA_NPAUHBA_PORT@@IIIPAG@Z PROC			; read

; 36   : 	port->is = (uint32_t) -1;		// Clear pending interrupt bits

	mov	ecx, DWORD PTR _port$[esp-4]

; 37   : 	int slot = find_cmdslot(port);

	mov	eax, DWORD PTR [ecx+56]
	or	eax, DWORD PTR [ecx+52]
	push	esi
	mov	DWORD PTR [ecx+16], -1
	xor	esi, esi
$LL13@read:
	test	al, 1
	je	SHORT $LN14@read
	inc	esi
	shr	eax, 1
	cmp	esi, 5
	jl	SHORT $LL13@read

; 39   : 		return false;

	xor	al, al
	pop	esi

; 117  : }

	ret	0

; 37   : 	int slot = find_cmdslot(port);

$LN14@read:

; 38   : 	if (slot == -1)

	cmp	esi, -1
	jne	SHORT $LN7@read

; 39   : 		return false;

	xor	al, al
	pop	esi

; 117  : }

	ret	0
$LN7@read:

; 40   : 
; 41   : 	//create CMD header
; 42   : 	HBA_CMD_HEADER *cmdheader = (HBA_CMD_HEADER*)port->clb;
; 43   : 	cmdheader += slot;

	shl	esi, 5
	add	esi, DWORD PTR [ecx]
	push	ebx

; 44   : 
; 45   : 	cmdheader->cfl = sizeof(FIS_REG_H2D)/sizeof(uint32_t);	// Command FIS size
; 46   : 	cmdheader->w = 0;		// Read from device

	mov	al, BYTE PTR [esi]

; 47   : 	cmdheader->prdtl = (uint16_t)((count-1)>>4) + 1;	// PRDT entries count
; 48   : 														// every entry will read 16 sectors
; 49   : 
; 50   : 	//create CMD  Table
; 51   : 	HBA_CMD_TBL *cmdtbl  = (HBA_CMD_TBL*) ((uint64_t) cmdheader->ctbau << 32 | cmdheader->ctba);

	mov	ecx, DWORD PTR [esi+12]
	and	al, 165					; 000000a5H
	or	al, 5
	push	edi
	mov	edi, DWORD PTR _count$[esp+8]
	mov	BYTE PTR [esi], al
	lea	eax, DWORD PTR [edi-1]
	shr	eax, 4
	inc	eax

; 52   : 	memset(cmdtbl, 0, sizeof(HBA_CMD_TBL) +
; 53   : 			((cmdheader->prdtl-1)*sizeof(HBA_PRDT_ENTRY)));

	movzx	edx, ax
	add	edx, 8
	shl	edx, 4
	push	edx
	xor	ebx, ebx
	or	ebx, DWORD PTR [esi+8]
	push	0
	push	ebx
	mov	WORD PTR [esi+2], ax
	call	?memset@@YAPAXPAXDI@Z			; memset

; 54   : 	
; 55   : 	
; 56   : 	// 8K bytes (16 sectors) per PRDT
; 57   : 	int i;
; 58   : 	for (i = 0; i < cmdheader->prdtl-1; i++){

	movzx	eax, WORD PTR [esi+2]
	mov	edx, DWORD PTR _buf$[esp+20]
	dec	eax
	add	esp, 12					; 0000000cH
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN4@read

; 40   : 
; 41   : 	//create CMD header
; 42   : 	HBA_CMD_HEADER *cmdheader = (HBA_CMD_HEADER*)port->clb;
; 43   : 	cmdheader += slot;

	lea	eax, DWORD PTR [ebx+140]
	push	ebp
	npad	2
$LL6@read:

; 59   : 		cmdtbl->prdt_entry[i].dba = (uint32_t) buf;
; 60   : 		cmdtbl->prdt_entry[i].dbc = 8*1024-1;	// 8K bytes (this value should always be set to 1 less than the actual value)

	mov	ebp, DWORD PTR [eax]
	and	ebp, -4186113				; ffc01fffH

; 61   : 		cmdtbl->prdt_entry[i].i = 1;			//notice how we set the same value to both dbc and move the buffer

	or	ebp, -2147475457			; 80001fffH
	mov	DWORD PTR [eax-12], edx
	mov	DWORD PTR [eax], ebp
	movzx	ebp, WORD PTR [esi+2]
	inc	ecx
	dec	ebp

; 62   : 		buf += 4*1024;	// 4K words				//the buffer is 16 bit for value so adding 1 to buffer pointer is

	add	edx, 8192				; 00002000H

; 63   : 		count -= 16;	// 16 sectors			//actilly add 16 bit to the pointer or 2 bytes. buf += X  <==> dbc = 2*X

	sub	edi, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, ebp
	jl	SHORT $LL6@read
	pop	ebp
$LN4@read:

; 64   : 												//same for count, sector is 512 bytes so devide the dbc by 512 to get count
; 65   : 												//remember to add 1 to dbc before any calculation here.
; 66   : 	}
; 67   : 	
; 68   : 	
; 69   : 	// Last entry
; 70   : 	cmdtbl->prdt_entry[i].dba = (uint32_t) buf;

	lea	eax, DWORD PTR [ecx+8]

; 71   : 	cmdtbl->prdt_entry[i].dbc = (count<<9)-1;	//the remainder of count * 512 bytes per sector

	shl	edi, 9
	add	eax, eax
	mov	DWORD PTR [ebx+eax*8], edx
	add	ecx, ecx
	mov	edx, DWORD PTR [ebx+ecx*8+140]
	lea	ecx, DWORD PTR [ebx+ecx*8+140]
	dec	edi
	and	edi, 4194303				; 003fffffH
	and	edx, -4194304				; ffc00000H

; 72   : 	cmdtbl->prdt_entry[i].i = 1;

	or	edi, edx
	or	edi, -2147483648			; 80000000H
	mov	DWORD PTR [ecx], edi
	pop	edi
	pop	ebx

; 73   : 
; 74   : 	int a = 1;
; 75   : 	a++;
; 76   : 	a *= 52;
; 77   : 
; 78   : 	for (int i=0, a=0, b=0, c=0, d=0, u=0; i < 52; i++){
; 79   : 		a++;
; 80   : 		b++;
; 81   : 		c++;
; 82   : 		d++;
; 83   : 		u++;
; 84   : 	}
; 85   : 
; 86   : 	/*
; 87   : 	// Create Fis
; 88   : 	FIS_REG_H2D *cmdfis = (FIS_REG_H2D*)(&cmdtbl->cfis);
; 89   : 	cmdfis->fis_type = FIS_TYPE_REG_H2D;
; 90   : 	cmdfis->c = 1;	// Command
; 91   : 	cmdfis->command = 0x25; //ATA_CMD_READ_DMA_EX
; 92   : 
; 93   : 	cmdfis->lba0 = (uint8_t)startl;
; 94   : 	cmdfis->lba1 = (uint8_t)(startl>>8);
; 95   : 	cmdfis->lba2 = (uint8_t)(startl>>16);
; 96   : 	cmdfis->device = 1<<6;	// LBA mode
; 97   : 
; 98   : 	cmdfis->lba3 = (uint8_t)(startl>>24);
; 99   : 	cmdfis->lba4 = (uint8_t)starth;
; 100  : 	cmdfis->lba5 = (uint8_t)(starth>>8);
; 101  : 
; 102  : 	cmdfis->countl = count & 0xFF;
; 103  : 	cmdfis->counth = (count >> 8) & 0xFF;
; 104  : 
; 105  : 	//waiting for port to be ready before send command
; 106  : 	int spin = 0; // Spin lock timeout counter
; 107  : 	while ((port->tfd & (ATA_DEV_BUSY | ATA_DEV_DRQ)) && spin < 1000000)
; 108  : 	{
; 109  : 		spin++;
; 110  : 	}	if (spin == 1000000) {
; 111  : 		return false;
; 112  : 	}
; 113  : 
; 114  : 	port->ci = (uint32_t) 1<<slot;	// Issue command
; 115  : 	*/
; 116  : 	return true;

	mov	al, 1
	pop	esi

; 117  : }

	ret	0
?read@@YA_NPAUHBA_PORT@@IIIPAG@Z ENDP			; read
_TEXT	ENDS
END
